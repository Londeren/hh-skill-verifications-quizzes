## Docker — продвинутый уровень

#### Содержание

- Продвинутый инструментарий Docker
- Анализ Docker Compose файлов для улучшения настройки и взаимодействия связанных контейнеров
- Организация и работа Docker Security

#### Вы заметили, что команда `docker build` для создания образов занимает значительно больше времени, чем ожидалось. После анализа Dockerfile выяснилось, что некоторые инструкции выполняются повторно, даже если они не изменялись.

Выберите верный вариант решения проблемы.

- [x] Использование кеширования слоев Docker — все неизмененные инструкции будут пропускаться, что значительно сократит время сборки
- [ ] Уменьшение размера базового образа сократит время сборки, исключив повторное выполнение неизмененных слоев
- [ ] Сборка на сервере с более мощным оборудованием сократит время выполнения инструкций и устраняет повторное выполнение неизмененных слоев
- [ ] Удаление ненужных инструкций включит кеширование и исключит повторное выполнение неизмененных слоев
- [ ] Установка флага `--no-cache` оптимизирует сборку за счет пропуска слоев с ненужными данными

#### В вашем Dockerfile используется инструкция ADD для копирования файлов и извлечения архива:

```Dockerfile
FROM nginx: latest
ADD /app.tar.gz /usr/share/nginx/html
ADD /config/nginx.conf /etc/nginx/nginx.conf
CMD ["nginx", "-g", "daemon off;"]
```

Вы заметили, что сборка образа занимает больше времени, чем ожидалось, а размер образа увеличивается из-за ненужных файлов. Вы внесли изменения.
После изменений:

1. Сборка образа стала занимать меньше времени.
2. Размер образа уменьшился, так как больше нет ненужных файлов из архива.

Какие изменения были внесены?

- [ ] Установка минимальной версии Nginx для уменьшения размера базового образа
- [ ] Уменьшение размера образа, удаление архива после его извлечения в Dockerfile
- [x] Замена `ADD` на `COPY` для копирования файлов и распаковка архива заранее
- [ ] Использование `ADD` для всех операций, так как это универсальная инструкция
- [ ] Перемещение `CMD` перед инструкцией `ADD` для ускорения сборки

#### В вашем Docker Compose файле для одного из сервисов включена настройка healthcheck, чтобы отслеживать его состояние. Однако вы замечаете, что зависимые сервисы запускаются сразу, игнорируя состояние healthcheck. Это приводит к тому, что они не могут подключиться к сервису, пока тот полностью не инициализирован. Вы проверяете файл и видите, что секция depends_on указана, но дополнительные параметры отсутствуют.

Какой недостаток в конфигурации может это вызывать?

- [ ] Наличие дополнительного сервиса в секции volumes
- [ ] Неправильная конфигурация секции `healthcheck`
- [ ] Отсутствие лимитов ресурсов в сервисах
- [x] Отсутствие параметра `condition` в зависимости `depends_on`
- [ ] Использование устаревшей версии Docker Compose файла

#### Ваше приложение использует два контейнера: АРІ и Redis. Они должны быть изолированы от других контейнеров в системе, но при этом поддерживать прямое взаимодействие между собой. Вы настроили отдельную сеть, но контейнеры не могут подключиться друг к другу.

Почему возникала проблема?

- [ ] Для контейнеров не настроены алиасы в сети, что мешает их взаимодействию через DNS
- [x] Поскольку контейнеры не подключены к одной и той же сети, они не могут взаимодействовать друг с другом
- [ ] Контейнеры подключены к разным `bridge`-сетям, что мешает их взаимодействию
- [ ] Один из контейнеров использует параметр `--network=host`, нарушая изоляцию сети и взаимодействие с другими контейнерами
- [ ] В секции `networks` отсутствует явное указание имени сети, что мешает контейнерам подключаться к одной сети

#### Контейнер api-gateway начал отвечать медленно, хотя нагрузка на сервис осталась прежней. Логи не содержат ошибок. СР и память загружены умеренно, но сетевые задержки выросли. Вход в контейнер запрещён политикой безопасности.

Как проверить текущее состояние сетевых соединений и определить возможные проблемы?

- [ ] Остановить контейнер через `docker stop`, создать образ через `docker commit` и перезапустить его в новой сети
- [ ] Использовать `docker top` для анализа процессов, `docker stats` для метрик и `docker inspect` для получения информации о сетевых параметрах
- [ ] Выполнить `docker kill`, собрать логи через `docker logs` и пересоздать контейнер заново
- [ ] Выполнить `docker logs --tail 200` для просмотра последних записей и `docker ср` для извлечения файла `/etc/hosts`
- [x] Запустить `docker network inspect` для анализа состояния сети хоста и `docker container inspect` для просмотра сетевой конфигурации контейнера

#### Контейнер запущен в пользовательском пространстве имён (userns-remap), но при этом все ещё может изменять состояние ядра Linux (например, менять параметры ядра через `sysctl`). Как это возможно?

- [ ] Применена политика `--security-opt apparmor=unconfined`
- [ ] Параметр `--privileged` был применён частично, что оставило некоторые возможности
- [x] Контейнер запущен с параметром `--cap-add=CAP_SYS_ADMIN`
- [ ] Контейнер использует хостовый `cgroup` (`--cgroupns=host`)
- [ ] Использован `--network host`, который дает доступ к управлению сетью и ядром

#### В вашей системе используются общие тома Docker для хранения данных базы данных и логов. Недавно вы столкнулись с проблемами:

1. Несколько томов были повреждены после неожиданного завершения работы контейнеров.
2. Данные базы данных оказались частично утерянными, а логи не обновлялись.
3. Резервное копирование настроено, но занимает слишком много времени.

Что вызвало эти проблемы?

- [ ] Отсутствие регулярного тестирования восстановления из резервных копий
- [ ] Неоптимальная конфигурация политики резервного копирования
- [ ] Отсутствие настроек автоматического создания снапшотов томов
- [ ] Использование томов без проверки доступности при запуске контейнеров
- [x] Использование локальных томов без отказоустойчивого хранилища

#### Вы настраивали систему мониторинга для контейнерных приложений, но столкнулись с проблемой, что уведомления о повышенной нагрузке (например, превышение предела CPU или памяти) не всегда приходят своевременно.

Почему это происходит?

- [ ] Grafana используется для постоянного мониторинга, но не настроена система для отправки уведомлений, а используется только визуализацию данных
- [ ] Используется Docker cli для логирования и анализа, но логи ежедневно просматриваются вручную
- [ ] Используется Cadvisor, но не настроены автоматические уведомления на основе собранных метрик, что приводит к отсутствию мгновенных оповещений
- [x] Настроен Prometheus Alertmanager, но не учтено, что правила уведомлений могут быть некорректно настроены для контейнерных ресурсов
- [ ] Используется команда docker logs для мониторинга контейнеров, но при этом уведомления не настроены, так как система мониторинга настроена только для ручного анализа логов

#### Вы хотите интегрировать Docker в пайплайн CI/CD для повышения стабильности развертывания.

Какой аспект контейнеризации Docker помогает минимизировать ошибки в процессе доставки приложений?

- [ ] Позволяет обновлять контейнеры без перезапуска пайплайна
- [ ] Заменяет инструменты оркестрации для управления пайплайном
- [ ] Исключает необходимость настройки сетей между контейнерами
- [ ] Автоматически исправляет ошибки конфигурации в приложениях
- [x] Стандартизирует среду на всех этапах пайплайна, исключая расхождения

#### Что безопаснее: использование инструкции `USER` в Dockerfile или параметра `-u <user>` при запуске контейнера?

- [ ] `USER` в Dockerfile, так как это позволяет избежать необходимости указывать пользователя при каждом запуске
- [ ] `-u <user>` при запуске, так как это позволяет гибко менять пользователя без изменения Dockerfile
- [x] `USER` в Dockerfile, так как это обеспечивает безопасность на этапе сборки и предотвращает запуск контейнера от `root`
- [ ] `-u <user>` при запуске, так как это повышает производительность контейнера
- [ ] `USER` в Dockerfile, так как это упрощает управление контейнерами и снижает вероятность ошибок

#### B production-среде с множеством Docker-контейнеров были обнаружены следующие проблемы:

А. Несколько контейнеров начали использовать неожиданно высокий объем сетевого трафика, что привело к перегрузке сети.
В. Логи показывают, что некоторые контейнеры пытаются получить доступ к ресурсам других контейнеров, к которым у них не должно быть доступа.
С. Один из контейнеров начал выполнять команды, которые не были предусмотрены его функциональностью.

В чем причина проблемы?

- [ ] Использование устаревших образов с известными уязвимостями, которые могут быть эксплуатированы злоумышленниками
- [ ] Использование пользовательских сетей Docker, но без ограничения доступа к критическим системным ресурсам хоста
- [ ] Отсутствие мониторинга сетевой активности контейнеров и использования инструментов для анализа трафика
- [x] Запуск контейнеров с параметром `--privileged`, что дает им полный доступ к хосту и другим контейнерам
- [ ] Использование изолированной `bridge`-сети с настроенными правилами `firewall`, что позволяет контролировать сетевой трафик контейнеров

#### Почему `overlay`-сеть в Docker лучше подходит для связи контейнеров на разных хостах?

- [x] Оптимизирована для связи контейнеров между разными хостами, снижая задержки
- [ ] Позволяет контейнерам использовать IP-адреса хоста, сильно ускоряя к ним доступ
- [ ] Автоматически масштабирует все сетевые ресурсы по мере возрастания нагрузки
- [ ] Использует частичное сжатие трафика, за счет этого уменьшает нагрузку на сеть
- [ ] Обеспечивает полную изоляцию контейнеров, блокируя любой внешний трафик

#### Вы развернули приложение на Docker, которое выполняет обработку большого количества сетевых запросов. Однако вы замечаете увеличенные задержки в сетевых операциях. Логи показывают, что стандартная сеть Docker имеет высокую задержку при обработке запросов. Это снижает производительность приложения, особенно при высокой нагрузке.

Какой способ поможет поднять производительность и снизить задержки?

- [ ] Добавить лимиты на количество подключений для каждого контейнера
- [ ] Ограничить доступ контейнеров к внешним API
- [ ] Настроить репликацию контейнеров для обработки сетевых запросов
- [x] Использовать пользовательскую сеть `overlay` для оптимизации сетевого взаимодействия
- [ ] Произвести замену текущей сети на bridge-сеть Docker

#### Какое преимущество использования секции `secrets` перед передачей данных через общие тома (volumes)?

- [ ] Тома требуют настройки сетевых политик для каждого контейнера
- [ ] Секреты автоматически кэшируются для ускорения запуска контейнеров
- [ ] Секреты можно изменять динамически без перезапуска сервисов
- [ ] Тома не поддерживают права доступа только для чтения
- [x] Docker управляет жизненным циклом секретов и ограничивает их доступность

#### Ваше приложение в Docker Swarm использует Docker Secrets для передачи конфиденциальных данных. При добавлении новых «секретов» вы заметили, что старый «секрет» перестает быть доступным сервису, который его использует.

Что нужно сделать, чтобы исправить это?

- [x] Перезапустить сервис, чтобы он получил доступ к новым и старым секретам
- [ ] Добавить все Секреты в общий том, доступный для сервиса
- [ ] Удалить новые Секреты и проверить конфигурацию Docker Secrets
- [ ] Обновить настройки ротации секретов для всех сервисов
- [ ] Сохранить старые Секреты как переменную окружения для временного доступа
