## API — продвинутый уровень

#### Какое ключевое преимущество REST делает его оптимальным для масштабируемых веб-сервисов?

- [x] `REST опирается на стандарты HTTP и методы GET, POST, PUT, DELETE, что упрощает интеграцию и масштабирование`

#### Ваше приложение должно взаимодействовать с RESTful API, а вы хотите протестировать корректность обработки POST-запросов. Вам необходимо проверить, что сервер правильно возвращает ошибки при некорректно сформированных данных в теле запроса. Тело запроса должно содержать JSON-объект с обязательными параметрами. Тестирование должно включать автоматическую проверку содержимого ответов на запросы.

- [x] `Настроить тело запроса во вкладке “Body”, выбрать формат JSON, отправить запрос и записать в “Tests” скрипт проверки статуса ответа и текста ошибки`

#### Вы выбираете метод аутентификации для API, который будет использоваться сторонними приложениями.

По какой причине OAuth 2.0 более безопасно для делегирования прав доступа по сравнению с Basic Authentication?

- [x] Позволяет сторонним приложениям получить доступ к ресурсам пользователя без передачи паролей
- [ ] Требует передачи паролей пользователя только один раз при создании токена
- [ ] Требует шифрования всех запросов, что делает его безопаснее Basic Authentication
- [ ] Использует многофакторную аутентификацию, что делает его более безопасным, чем Basic Authentication
- [ ] Автоматически проверяет подлинность всех пользователей перед каждым запросом

#### Вы создаете мобильное приложение, которое должно обращаться к вашему API от имени пользователя. Требуется обеспечить безопасный доступ и возможность отозвать доступ в любое время.

Какова связь с фактором безопасности и управления доступом при выборе метода аутентификации для такой функциональности?

- [x] `OAuth 2.0 позволяет предоставлять ограниченный доступ к ресурсам без передачи учетных данных пользователя`

#### Ваш API обрабатывает запросы на обновление ресурса. Клиент отправляет запрос с некорректным синтаксисом в теле (например, отсутствует обязательное поле) и идентификатором ресурса, которого нет в системе. Сервер должен выбрать приоритетную ошибку, чтобы корректно уведомить клиента о причине отказа.

Почему в этой ситуации сервер должен использовать код 400 для обработки ошибки?

- [x] `Синтаксическая ошибка в теле запроса делает невозможным дальнейшую обработку, включая проверку существования ресурса`

#### Ваша микросервисная система обрабатывает заказы в режиме реального времени. Разные узлы могут одновременно обновлять одни и те же заказы. При этом клиенты порой дублируют запросы PUT или PATCH, пытаясь гарантированно применить изменения, а также повторяют запросы после таймаутов. Вам нужно обеспечить идемпотентность и избежать «гонок», из-за которых один узел может перезаписать изменения другого, нарушая согласованность данных.

Какой подход к CRUD-операциям позволит эффективно поддерживать идемпотентность и управление конкурентными обновлениями в распределённой среде?

- [x] Применять PUT с условными заголовками, чтобы при конфликте версий сервер отклонял повторные запросы или запросы с устаревшими данными
- [ ] Отключить частичное обновление (РАТСН) и всегда создавать новые ресурсы при изменении, избегая одновременных операций над одним заказом
- [ ] Хранить все изменения в очереди и выполнять их последовательно на одном узле, исключая параллельную обработку
- [ ] Использовать простые PUT-запросы без версии ресурса, позволяя любому узлу перезаписывать поля независимо от текущего состояния
- [ ] Разрешать клиентам отправлять дубликаты запросов POST для актуализации информации, полагаясь на уникальный ключ в теле запроса

#### Во время обновления статуса заказа методом PATCH некоторые клиенты столкнулись с неожиданными потерями данных. Вам нужно выявить паттерн ошибок и определить, в каких ситуациях этот метод может привести к потере данных.

Какое свойство метода PATCH может привести к потере данных при отправке пустых или отсутствующих значений в запросе? PATCH…

- [x] `Обрабатывает пустые значения в запросе, заменяя текущие значения на пустые`

#### Ваш API позволяет удалять заказы клиентов. При удалении заказа дочерние данные (например, связанные товары) не удаляются, что нарушает целостность базы данных. Вам нужно устранить эту проблему.

Какой подход вы выберете для сохранения целостности данных при удалении зависимых ресурсов?

- [x] `Настроить каскадное удаление для связанных ресурсов`

#### Вы используете WebSocket для передачи данных клиентам. Некоторые клиенты сталкиваются с потерей соединения из-за проблем в сети. Вам нужно обеспечить восстановление соединения и надёжную доставку пропущенных уведомлений.

Как обеспечить восстановление WebSocket-соединения и надёжную доставку уведомлений, пропущенных из-за сетевых сбоев?

- [x] `Использовать брокер сообщений для хранения событий до их доставки клиенту`

#### Вы планируете опубликовать своё API для внешних разработчиков и хотите предоставить актуальную документацию, которая автоматически обновляется при изменениях в коде. Список факторов:

1.  Использование аннотаций кода для генерации документации.
2.  Возможность преобразования спецификации OpenAPI в различные языки программирования.
3.  Генерация пользовательского интерфейса (UI), который отображает текущее состояние API.

Какие из перечисленных факторов связаны с поддержкой автоматического обновления документации в OpenAPI?

- [x] `Факторы 1 и 3`

#### Ваш API возвращает большие объемы данных в форматах JSON и XML. Вы замечаете, что XML-ответы занимают больше ресурсов на сервере. Необходимо оптимизировать производительность для обработки таких запросов.

Какой подход вы выберете для улучшения работы с XML?

- [x] `Буду передавать XML-ответы в сжатом формате (gzip)`

#### Вы настраиваете JWT-аутентификацию для банковского API.

Система должна одновременно:

1.  Снижать риск компрометации access-токенов
2.  Не заставлять мобильных пользователей часто вводить пароль
3.  Позволять немедленно отзывать токены при обнаружении утечки

Какую конфигурацию сроков действия и сопутствующих механизмов следует использовать?

- [x] `Access 15 мин + refresh 7 дней с серверным blacklist / rotation каждого refresh-токена`

#### Вы разрабатываете e-commerce платформу с GraphQL API. При оформлении заказа нужно выполнить сразу несколько действий: проверить наличие товара на складе, рассчитать стоимость доставки и создать новую запись заказа в базе. Все три действия необходимо выполнить как единую атомарную операцию: если одно из них не удалось, остальные должны быть отменены или возвращены в исходное состояние.

Какой подход к GraphQL следует применить, чтобы реализовать одну транзакцию, способную одновременно проверять наличие товара, рассчитывать стоимость и создавать запись заказа, сохраняя целостность данных?

- [x] `Применить Mutation, объединив все действия в один резолвер, который обрабатывает транзакцию`

#### Ваш API обслуживает тысячи клиентов, и вы замечаете, что несколько из них отправляют аномально большое количество запросов в короткий промежуток времени. Это негативно влияет на производительность и приводит к сбоям в обработке запросов других клиентов. Вам нужно внедрить гибкое ограничение нагрузки через API Gateway, которое будет учитывать:

1. Идентификацию клиентов (например, через токены).
2. Дифференциацию правил (например, VIP-клиенты могут отправлять больше запросов).
3. Мгновенную блокировку клиентов, нарушающих лимиты.

Как настроить API Gateway для решения этой задачи?

- [x] `Сформировать функцию rate-limiting с динамическими лимитами, привязанными к идентификаторам клиентов`

#### Ваш API поддерживает запросы, возвращающие большие массивы данных (до 100 000 записей), но клиенты редко используют более 10% этих данных. Например:

1. В 70% случаев пользователи запрашивают только одно поле, такое как «название» или «ID».
2. Текущая архитектура не поддерживает выборку отдельных полей, что приводит к задержкам.
3. Данные генерируются динамически, и каждый большой запрос потребляет значительные ресурсы сервера.
4. У клиентов возникают ошибки из-за попыток фильтровать данные на своей стороне.

Какой из предложенных подходов наиболее подходит для улучшения производительности API минимизируя передаваемые данные?

- [x] `Добавить поддержку параметров для выборки полей и фильтрации данных на сервере`

#### В системе обработки медицинских данных требуется:

1. Поддержка транзакционности операций
2. Гарантированная доставка сообщений
3. Соответствие НІРАА требованиям безопасности
4. Интеграция с legy-системами на IBM Mainframe.
   Выберите верное обоснование. Какой протокол предпочтительнее: REST или SOAP?

- [ ] REST, потому что НРАА допускает защиту данных на уровне TLS, и можно избежать сложности WS-Security
- [ ] REST, так как OAuth 2.0 и JWT позволяют реализовать гибкую авторизацию, соответствующую требованиям HIPAA
- [ ] REST с gRPC, так как НТТР/2 снижает задержки, а interceptors можно использовать для имитации транзакций
- [x] SOAP, так как WS-AtomicTransaction и WS-ReliableMessaging обеспечивают требования, а WS-Security с XML-Encryption соответствует НРАА
- [ ] SOAP, потому что WSDL позволяет типизированную интеграцию с IBM Mainframe-системами

#### Вы документируете RESTful API с помощью Swagger и хотите проверить, как ваше приложение взаимодействует с различными эндпоинтами АРІ. Документация должна включать интерактивное тестирование всех эндпоинтов. Вы хотите предоставить разработчикам возможность тестировать АРІ без использования сторонних инструментов, таких как Postman.

Какую последовательность действий следует выполнить в Swagger, чтобы предоставить интерактивную документацию с возможностью тестирования эндпоинтов?

- [ ] Создать коллекцию запросов в Postman и экспортировать их для тестирования
- [ ] Добавить примеры запросов вручную в виде текстового описания к каждому эндпоинту
- [ ] Настроить Моск-сервер для тестирования всех эндпоинтов АРІ
- [x] Настроить спецификацию ОрепАРІ и включить Swagger Ul для автоматического отображения эндпоинтов и их тестирования
- [ ] Использовать вкладку "Authorization" в Swagger для генерации токенов доступа к АРІ

#### В вашем АРІ используется JWT для аутентификации. Однако пользователи столкнулись с ошибкой, после того как токен был скомпрометирован. Пользователи не могли отозвать токен, что привело к неконтролируемому доступу к ресурсам до истечения срока его действия.

Выберите ответ, который верно описывает свойства метода JWT, которые приводят к такой ошибке.

- [ ] JWT поддерживают обновление токенов при каждом запросе, повышая безопасность
- [ ] Токены имеют очень короткий срок жизни, что сильно ограничивает вероятность их компрометации
- [x] Токены являются автономными и содержат всю информацию о пользователе, что делает их неподконтрольными серверу
- [ ] JWT требуют сложного алгоритма проверки подписи, который может замедлять работу самой системы
- [ ] JWT зависят от внешнего сервиса для хранения данных о сессиях

#### Ваш API поддерживает регистрацию новых пользователей. Клиент отправляет запрос на регистрацию, который проходит базовую проверку синтаксиса, но содержит данные, не соответствующие правилам валидации (например, неверный формат email или слабый пароль). Сервер должен уведомить клиента о проблеме.

Почему сервер должен использовать код 422 для этой ситуации? Так как...

- [x] Он ясно указывает, что данные запроса не соответствуют требованиям, даже если синтаксис корректен
- [ ] Он информирует клиента о необходимости пересмотреть содержимое данных для успешной обработки запроса
- [ ] Несоответствие данных требованиям требует от клиента корректировки, а не изменения структуры запроса
- [ ] Он выделяет ошибки валидации данных, делая их понятными для клиента
- [ ] Сервер не может обработать запрос из-за неверных данных, а не из-за ошибок в синтаксисе

#### Ваш АРІ обновляет данные профилей пользователей. При высокой нагрузке возникает множество повторяющихся PUT-запросов почти одновременно, что приводит к лишней записи в базу данных и конфликтам в распределенной среде. Из-за этого часть запросов дублирует уже внесенные изменения или вызывает рассогласованность данных. Необходимо, чтобы метод PUT оставался идемпотентным и повторная отправка тех же данных не меняла итоговое состояние.

Как обеспечить корректную обработку повторных PUT-запросов, сохраняя идемпотентность метода?

- [ ] Использовать кэширование, чтобы блокировать повторные запросы от одного клиента
- [x] Проверить, совпадают ли данные из нового запроса с текущими данными
- [ ] Добавить параметр timestamp в каждый запрос для предотвращения коллизий
- [ ] Переключить метод с PUT на РАТСН, чтобы ограничить повторное обновление
- [ ] Переключить логику обработки на асинхронный режим

#### Ваш АРІ должен подерживать массовую рассылку уведомлений в реальном времени для десятков тысяч клиентов. Использование прямых WebSocket-соединений вызывает чрезмерную нагрузку на сервер.

Вам нужно выбрать правильное решение, которое решает проблему масштабирования и обеспечивает высокую доступность.

- [x] Использовать брокеры сообщений, такие как RabbitMQ или Kafka, для управления уведомлениями
- [ ] Переключиться на SSE, чтобы уменьшить нагрузку от двусторонних соединений
- [ ] Разделить сервер на несколько экземпляров и использовать балансировщик нагрузки
- [ ] Использовать Webhooks вместо WebSocket для масштабируемости
- [ ] Применить шардирование клиентов на основе их идентификаторов

#### Вы внедряете автоматическую генерацию спецификаций ОрепАРІ в 3 окружениях: dev, staging и production. Возникла необходимость регулярно синхронизировать документацию в промежуточном окружении (staging), чтобы QA-команда всегда имела актуальные сведения о новых методах и изменениях в АРІ. Приведен список факторов, которые могут влиять на успешную интеграцию автоматизированной документации:

1. Автоматическая выгрузка спецификаций ОрепАРІ из основного репозитория при каждом пуше (commit).
2. Генерация документации только в окружении production по расписанию (cron), без учета изменений в staging.
3. Использование pipeline для сборки и проверки документации при каждом пул-реквесте в ветку staging.
4. Интеграция с системой contract testing, которая валидирует соответствие кода актуальной спецификации в каждом окружении.
5. Разделение документации: dev-версия для отладки, staging-версия для тестирования, production-версия для внешних пользователей.

Какие или какой из перечисленных факторов (1-5) наиболее эффективно обеспечивают актуальность документации в окружении staging?

- [ ] Только фактор 1
- [ ] Только факторы 2 и 4
- [ ] Только фактор 5
- [x] Факторы 3, 4 ท 5
- [ ] Факторы 1 и 3

#### Ваш API должен быть совместим с клиентами, которые работают с различными форматами данных. У некоторых клиентов устаревшие системы, принимающие только XML, тогда как другие используют современные приложения, требующие JSON. Вы хотите, чтобы сервер оставался универсальным, позволяя клиентам выбирать предпочтительный формат ответа с минимальными изменениями в коде. При этом нужно учесть REST-подход и оптимальную поддержку контент-негациации.

Какой, из перечисленных ниже, самый оптимальный способ организации API, дающий возможность клиенту выбирать предпочтительный формат данных в ответе?

- [ ] Использовать для этого параметр query
- [ ] Предоставить разные эндпоинты для каждого формата
- [x] Использовать заголовок Accept в НТТР-запросе
- [ ] Использовать параметр в URL
- [ ] Определить формат ответа на основе выбранного клиентом соответствующего ІР-адреса

#### Вы хотите добавить информацию о ролях и правах пользователя в JWT-токен, чтобы использовать его для авторизации.

Каким образом лучше всего включить эти данные в JWT, чтобы обеспечить их безопасность и актуальность?

- [ ] Добавить роли и права в заголовок токена, чтобы они всегда были видны при передаче данных
- [x] Включить информацию о ролях в полезную нагрузку токена и подписывать JWT с использованием безопасного алгоритма
- [ ] Хранить права и роли на сервере, а в JWT-токен добавлять только уникальный идентификатор пользователя
- [ ] Включить роли в URL-параметры каждого запроса, чтобы не использовать сложные методы ПОДПИСИ
- [ ] Передавать роли и права пользователя в виде зашифрованных данных в теле ответа на каждый запрос

#### Вы разрабатываете платформу для онлайн-курсов, где студенты могут получать уведомления о новых лекциях и изменениях в расписании в режиме реального времени. Приложение должно обрабатывать большие объемы соединений, поскольку одновременно может быть подключено несколько тысяч студентов. При этом некоторые события должны быть доставлены только подписчикам, имеющим права доступа к определенному курсу (авторизация и фильтрация событий).

Какой подход при реализации GraphQL Subscriptions позволит масштабировать потоки событий и обеспечит авторизацию пользователей на уровне отдельных подписок, не дублируя логику в основном коде?

- [ ] Организовать проверку доступа на этапе установления соединения, сохраняя связанные данные для последующего управления подписками
- [ ] Реализовать директивы GraphQL, которые ограничивают доступ к данным подписки на основе пользовательских ролей
- [x] Использовать логику проверки авторизации внутри resolver для подписок, чтобы фильтровать данные перед их передачей
- [ ] Включить брокер сообщений, такой как Kafka, для обработки подписок и управления потоками данных на этапе доставки
- [ ] Настроить использование middleware, которое выполняет проверку прав пользователя перед установлением соединения для подписки

#### Ваш АРI поддерживает четыре основные версии, каждая из которых реализует схожую функциональность с незначительными изменениями. Например:

1. Версии 1 и 2 возвращают данные в разных форматах (JSON, XML).
2. Версия 3 добавляет параметры для фильтрации, которые отсутствуют в других версиях.
3. Версия 4 поддерживает агрегированные данные для определенных отчетов.
4. Разработчики вынуждены поддерживать эти версии, внося изменения вручную в каждую из них. Это приводит к ошибкам, задержкам и дублированию кода. Также пользователи жалуются на сложность работы с API, так как документация недостаточно детализирована для каждой версии.

Какой подход поможет уменьшить сложность кода, сохранить обратную совместимость и упростить обновления API, сохраняя обратную совместимость для существующих клиентов?

- [x] Внедрить API Gateway для управления запросами к разным версиям
- [ ] Добавить возможность передачи всех параметров через единый объект, чтобы сократить количество дублирующего кода
- [ ] Объединить ключевые функции из всех версий в одну универсальную реализацию, сохранив совместимость через параметры
- [ ] Удалить старые версии АРІ и оставить только последнюю, предложив клиентам обновиться
- [ ] Реализовать конвертер форматов данных на уровне клиента, чтобы уменьшить число поддерживаемых версий
