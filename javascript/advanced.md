## JavaScript — продвинутый уровень

#### Какой из массивов НЕ будет выведен после выполнения этого кода?

```js
let fruits = ["Яблоко", "Апельсин", "Слива"];
const fruits1 = ["Яблоко", "Апельсин", "Слива"];
fruits1[0] = "Мандарин";
function test() {
  const fruits1 = ["Малина", "Клубника", "Смородина"];
  let fruits = ["Груша", "Крыжовник", "Агрэст"];
  fruits[0] = "Мандарин";
  console.log(fruits);
}
test();
console.log(fruits1);
console.log(fruits);
```

- [x] `["Малина", "Клубника", "Смородина"]`

#### Перед вами поставили задачу написать веб-приложение «Крестики-нолики». По техническому заданию вам необходимо сохранять состояние игры. Например, вы можете сохранить текущего игрока, расположение крестиков и ноликов на игровом поле и другие данные, чтобы игра могла быть возобновлена после перезагрузки страницы.

- [x] LocalStorage

#### Каким будет результат выполнения следующего выражения в JavaScript?

`"10" + 2 * "5"`

- [x] 1010

#### Из массива чисел вам нужно сначала отфильтровать четные числа, затем удвоить их и, наконец, вычислить сумму. Какой код это выполняет?

- [x] numbers.filter(n => n % 2 === 0).map(n => n \* 2).reduce((sum, n) => sum + n, 0)

#### Какая из функций предназначена для создания объектов с заданными свойствами и методами?

- [x] Функция-конструктор (constructor function)

#### Что будет выведено в консоль при выполнении данного кода?

```js
functiоn countеr() {
   var cоunt = 0;
   return functiоn() {
      return ++cоunt;
   }
}


vаr incrеment = cоuntеr();
cоnsolе.log(increment());
cоnsolе.log(increment());
cоnsolе.log(increment());
```

- [x] 1, 2, 3

#### В какой последовательности выполняются операции в следующем коде, который включает асинхронные операции и взаимодействие с сетью? Учтите, что обработка запроса не будет закончена до того, как выполнится весь синхронный код программы.

```js
consolе.lоg("Начало");

sеtTimeоut(() => {
  console.lоg("SetTimeоut 1");
}, 0);

fеtch("https://api.example.cоm/data")
  .thеn((respоnse) => responsе.json())
  .thеn((data) => {
    consоlе.log("Данные получены:", data);
  });

sеtTimeоut(() => {
  consоle.log("SеtTimeоut 2");
}, 0);

consоlе.lоg("Конец");
```

- [x] Начало, Конец, SetTimeout 1, SetTimeout 2, Данные получены: [данные].

#### Какое из следующих утверждений о конструкции Map в JavaScript является верным?

- [x] Map гарантирует, что элементы будут храниться в порядке добавления.

#### Вам нужно создать неглубокую копию объекта и массива в JavaScript, при этом важно сохранить методы, определенные в самом объекте (без учета прототипной цепочки). Какой из следующих методов или подходов вы выберете?

- [x] `const newObj = {...obj}, newArr = [...arr]`

#### У вас есть следующий код. Что будет выведено в консоль при его вызове?

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  speak() {
    super.speak();
    console.log(`${this.name} barks.`);
  }
}

let dog = new Dog("Rex");
dog.speak();
```

- [x] "Rex makes a noise." и затем "Rex barks."

#### Вы разрабатываете интерфейс для интернет-магазина, который должен содержать витрину для тысячи товаров. Какой подход стоит использовать, чтобы обеспечить плавное и быстрое отображение этих товаров при прокрутке и избежать задержек и «зависаний» интерфейса?

- [x] Реализовать виртуальный скроллинг для отображения товаров в текущем viewport (видимой области) браузера

#### Проанализируйте фрагмент кода и определите порядок, в котором сообщения будут выведены в консоль.

```js
console.log("1");

setTimeout(function () {
  console.log("2");
  Promise.resolve().then(function () {
    console.log("3");
  });
}, 0);

Promise.resolve().then(function () {
  console.log("4");
  setTimeout(function () {
    console.log("5");
  }, 0);
});

requestAnimationFrame(function () {
  console.log("7");
});

console.log("6");
```

- [x] 1, 6, 4, 2, 3, 5, 7

#### Для чего применяется tree shaking в системах сборки JavaScript на прикладном уровне?

- [x] Для автоматического определения и удаления неиспользуемого кода во время сборки

#### Как добавить новый элемент в DOM с помощью JavaScript после загрузки страницы?

- [x] Используя комбинацию методов `document.createElement()` и `document.appendChild()`

#### Вы работаете над SPA (Single Page Application), которое активно обращается к API для обработки действий пользователя и вывода изменяющегося контента. Ваша задача — увеличить производительность приложения и сократить время полной первой отрисовки страницы. У вас в наличии мощный сервер, вы не ограничены пропускной способностью сетевого оборудования.

- [x] Server-Side Rendering (SSR)

#### Какое значение НЕ будет выведено в консоль после выполнения следующего кода?

```js
const user = { name: "Alice", age: 25 };
function updateUser(obj) {
  obj.age = 30;
  const user = { name: "Bob", age: 40 };
  console.log(user.name);
  console.log(user.age);
}
updateUser(user);
console.log(user.age);
console.log(user.name);
```

- [ ] 30
- [x] 25
- [ ] 40
- [ ] "Bob"
- [ ] "Alice"

#### В современном веб-приложении социальной сети необходимо сохранять не только базовые настройки пользователя, но и сложные объекты (например, параметры отображения, избранный контент и настройки приватности). Данные должны храниться локально, поддерживать транзакционную целостность и масштабироваться с ростом объема информации, при этом не требуя постоянного обмена с сервером. Какой тип хранилища вы подберете для данной задачи?

- [ ] Cookies
- [ ] LocalStorage
- [x] IndexedDB
- [ ] Web SQL Database
- [ ] sessionStorage

#### Каким будет результат выполнения следующего выражения в JavaScript?

```js
3 + 4 + 15' - 2
```

- [ ] '75'
- [ ] '345'
- [ ] 10
- [ ] 9
- [x] 73

#### Из массива чисел нужно отфильтровать числа больше 10, умножить их на 3 и вычислить сумму. Какой код это выполняет?

- [ ] `numbers.filter(n = n * 3 > 10). reduce((s, n) => s + n, 0)`
- [ ] `numbers.filter(n = n > 10).map(n => n * 3). reduce((s, n) => s + n, 1)`
- [ ] `numbers.map (n => n + 10).filter(n => n % 3 === 0). reduce((s, n) => 5 + n, 0)`
- [ ] `numbers.map (n => n * 3).filter(n => n > 10). reduce((s, n) => s + n, 0)`
- [x] `numbers. reduce((s, n) => n > 10 ? s + n * 3 : s, 0)`

#### Какая разновидность функции, будучи анонимной, может присваиваться переменной и при этом сохранять доступ к локальной области видимости за счёт замыкания?

- [ ] Генераторная функция (generator function)
- [ ] Функция-конструктор (constructor function)
- [x] Функциональное выражение (function expression)
- [ ] Самовызывающаяся функция (I|FE)
- [ ] Функция обратного вызова (callback function)

#### Что будет выведено в консоль при выполнении данного кода?

```js
function nestedIncrementers(start) {
  return function () {
    let current = start;
    return function () {
      return ++current;
    };
  };
}
const init = nestedIncrementers(5);
const inc = init(); // возвращает внутреннюю функцию
console.log(inc());
console.log(inc());
```

- [ ] 5,5
- [ ] undefined, undefined
- [ ] 5,6
- [ ] 6,8
- [x] 6,7

#### В какой последовательности выполняются операции в следующем коде, который включает асинхронные операции и взаимодействие с сетью? Учтите, что обработка запроса не будет закончена до того, как выполнится весь синхронный код программы.

```js
async function getData() {
  console.log("Начинаем запрос");
  const response = await fetch("https://api.example.com/data");
  console.log("После await");
  const data = await response.json();
  console.log("Данные:", data);
}
console.log("Синхронный 1");
getData();
console.log("Синхронный 2");
```

- [ ] Синхронный 1, Начинаем запрос, Синхронный 2, Данные: .., После await
- [ ] Начинаем запрос, После await, Данные: ..., Синхронный 1, Синхронный 2
- [ ] Синхронный 1, Синхронный 2, Начинаем запрос, После await, Данные: ...
- [x] Синхронный 1, Начинаем запрос, Синхронный 2, После await, Данные: ...
- [ ] Начинаем запрос, Синхронный 1, Синхронный 2, После await, Данные: ...

#### Какое из следующих утверждений о методе Object.assign() является верным?

- [ ] Object.assign() автоматически удаляет свойства, содержащие функции, если они присутствуют в исходном объекте, так как методы не могут быть скопированы
- [ ] Object.assign() выбрасывает ошибку, если целевой объект (target) уже содержит свойство с таким же именем, так как не может перезаписывать существующие значения
- [x] Object.assign() копирует свойства из одного или нескольких исходных объектов в целевой объект, перезаписывая совпадающие свойства
- [ ] Object.assign() выполняет глубокое копирование всех вложенных объектов по умолчанию, обеспечивая независимость копий от оригинала
- [ ] Object.assign() объединяет только свойства, у которых тип равен string; все остальные типы игнорируются

#### Вы хотите объединить свойства двух объектов и элементы двух массивов, при этом для объектов нужно сохранить методы, хранящиеся как собственные свойства, а для массивов исключить дубликаты. Как лучше всего добиться этого?

- [ ] `const merged0bj = JSON.parse(JSON.stringify(obj1, obj2)); const mergedArr =`
- [x] `const mergedobj = {...obj1, ...obj2}; const mergedArr = [...new Set([...arr1`
- [ ] `const mergedobj = {...obj1}; merged0bj.proto = obj2; const mergedArr = Array`
- [ ] `const mergedobj = Object.assign(objl, obj2); const mergedArr = arrl. push(...`
- [ ] `const merged0bj = Object.create(obj2, Object.get0wnPropertyDescriptors(objl)`

#### У вас есть следующий код. Что будет выведено в консоль при его вызове?

```js
class MyArray extends Array {
   constructor(...elements) {
      super(...elements);
      this.extra = elements.length > 0 ? elements [0] * 2 : 0;
   }
   lastElement () {
      return this.at(-1);
   }
   static fromArray (arr) {
      return new MyArray(...arr.filter (el => el % 2 === 0)):
   }
}
const arr = new MyArray(5, 10, 15, 20);
const arr2 = MyArray.fromArray([1, 2, 3, 4, 5, 6]):
console.log(arr instanceof Array); console.log(arr.lastElement());
console.log(arr.extra); console.log(arr2.length);
console.log(Object.getPrototype0f(arr) === MyArray.prototype);
console.log(Array.isArray(arr2));
```

- [ ] true, 15, 5, 3, true, true - lastElement() возвращает неправильный элемент, extra содержит исходное значение вместо удвоенного, что делает реализацию некорректной
- [ ] false, 20, 10, 3, false, false - наследование от Array работает некорректно, instanceof не срабатывает, а lastElement() не видит отрицательный индекс
- [ ] Ошибка TypeError: Cannot call method 'at' of undefined - метод at(-1) ломается на экземплярах классов, унаследованных от Array, при вызове lastElement()
- [ ] true, undefined, 5, 3, true, true - метод lastElement() не работает, так как at(-1) не поддерживается на расширенных массивах, а extra хранит оригинальный первый элемент
- [x] true, 20, 10, 3, true, true - класс работает корректно, arr наследуется от Array, lastElement() использует at(-1), extra - удвоенный первый элемент, fromArray фильтрует чётные

#### Вам необходимо вывести на одной странице большое количество текстовых записей. Как можно уменьшить нагрузку на сеть и ускорить первичную отрисовку элементов?

- [ ] Использовать localStorage для хранения всех данных и загружать их при каждом обновлении страницы
- [ ] Сразу загружать весь HTML-код элементов с сервера и вставлять его в DOM через innerHTML
- [x] Внедрить lazy loading для тяжёлых ресурсов, чтобы они подгружались только при необходимости
- [ ] Загружать данные синхронно через fetch в цикле for, чтобы гарантированно отрендерить все элементы
- [ ] Применить множественные таймеры setTimeout, чтобы разбивать процесс рендеринга на фрагменты

#### Какой результат выполнения этого кода будет неизменно верным?

```js
console.log(1);
setTimeout (() => {
   console.log(2);
   Promise.resolve().then(() => {
      console.log(3);
   }) ;
}, 0);
Promise.resolve().then(() => {
   console.log(4);
}):
requestAnimationFrame (() => {
   console.log(5);
   setTimeout(() => {
      console.log(6);
   }, 0);
}) ;
console.log(7);
```

- [ ] requestAnimationFrame блокирует очередь микрозадач, поэтому 4 может задержаться
- [ ] 5 будет выведено раньше 4, так как requestAnimationFrame срабатывает до микрозадач
- [x] 1, 7, и 4 всегда будут выведены раньше, чем 2, 3, 5, и 6, вне зависимости от нагрузки
- [ ] З может появиться раньше 2, если Promise.resolve() будет оптимизирован движком
- [ ] Порядок 5, 6 может поменяться местами, если requestAnimation Frame вызовется позже setTimeout

#### Для чего используется Hot Module Replacement в Webpack?

- [ ] Для генерации расширенного отчёта о зависимостях и внутренней структуре проекта
- [ ] Для автоматического удаления неиспользуемого и дублирующегося кода при сборке проекта
- [ ] Для уменьшения размера финального бандла за счет агрессивной оптимизации
- [x] Для обновления измененных модулей без полной перезагрузки страницы, что ускоряет процесс разработки
- [ ] Для динамической загрузки модулей во время выполнения без необходимости полной компиляции

#### Как реализовать делегирование событий для динамически добавленных элементов, чтобы при клике на любой из них сработал единый обработчик? Предполагается использование нативного JavaScript, без библиотек.

- [ ] Привязывать обработчик индивидуально каждому новому элементу через свойство onclick
- [ ] Использовать jQuery.on(), передавая родительский селектор и тип события для правильного делегирования
- [x] Назначить обработчик на родителя через addEventListener и внутри него проверять event.target
- [ ] Применить метод element.delegateEvent(), позволяющий автоматически перенаправлять события к родительскому элементу
- [ ] Использовать метод document.write() для вставки обработчика в HTML-код

#### При первой загрузке SPA (Single Page Application) выполняются ресурсоемкие расчеты, блокирующие основной поток и задерживающие отрисовку. Для повышения производительности необходимо вынести тяжёлые вычисления в отдельный поток.

Какой метод вы используете для достижения этой цели?

- [ ] Кэширование ответов АРІ в localStorage, чтобы сохранять данные локально и сократить количество сетевых запросов
- [ ] Server-Side Rendering (SSR), чтобы предварительно рендерить контент на сервере и ускорить загрузку страниц
- [ ] Оптимизация событий с помощью Throttling и Debouncing, чтобы снизить частоту вызовов обработчиков и уменьшить нагрузку на процессор
- [x] Использование Web Workers, чтобы выполнять вычисления в фоновом потоке и не блокировать интерфейс
- [ ] Динамическое импортирование модулей, чтобы загружать код только по мере необходимости и уменьшить размер бандла
