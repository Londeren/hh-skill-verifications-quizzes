## Git — продвинутый уровень

#### Команда разработчиков решила хранить большие бинарные файлы (изображения и видео) в репозитории Git. Все изменения в них фиксируются напрямую в коммитах без каких-либо других хранилищ и технологий.Оцените, насколько правильно использовать Git в таком сценарии и почему.

- [ ] Такая практика может подойти, но проблем с производительностью не возникнет, только если размер аждого файла - не больше 100 МБ
- [ ] Такая практика может подойти, но надо ограничить формат только видеофайлами - они лучше сжимаются прикоммитах
- [ ] Это нормальная практика - Git подходит для хранения любых типов файлов, так что проблем не возникнет
- [ ] Так можно сделать, но только если файлов не больше 50, иначе пространство памяти Git переполнится и выполнять коммиты станет невозможно
- [x] Это некорректно - хранение больших файлов в Git может значительно ухудшить производительность репозитория, так как Git не оптимизирован для работы с большими файлами

#### Вы с коллегой работаете над новой функциональностью в АРІ в ветке feature/api-implementation. Ваш коллега обнаружил, что в вашей ветке есть ошибка, которая уже исправлена в ветке main. Однако в main есть изменения, несовместимые с вашей текущей веткой. Ваш коллега выполнил действия для исправления этой ошибки. Определите по текущему и предыдущему состоянию веток, какую команду выполнил ваш коллега? Учтите: он точно НЕ копировал изменения в вашу ветку вручную.

Состояние ветки feature/api-implementation ДО Изменений:

```
80a8cf6: New api implementation
1c69684: V2
99a9c09: V1
```

Состояние ветки main:

```
d5bb6b8: V3
Cle97fl: API hot-fix
1c69684: V2
99a9c09: V1
```

Текущее состояние ветки feature/api-implementation:

```
4fde353: API hot-fix
80a8cf6: New api implementation
1c69684: V2
99a9c09: V1
```

- [ ] git pull c1e97f1
- [ ] git checkout c1e97f1
- [ ] git rebase main
- [x] git cherry-pick c1e97f1
- [ ] git merge --no-ff main

#### Вы работаете над проектом и замечаете, что изменения, которые касаются исправления ошибки в форме в ветке feature/data-form, исчезли, хотя раньше они точно были.

Вы выполняете команду `git log` и видите следующий вывод:

```
commit 1c69684
Author: Some Developer
Date: Mon Dec 10 10:00:00 2024
Initial implementation of form functionality

commit 5f62b1с
Author: Some Developer
Date: Mon Dec 9 18:30:00 2024
Added database connection
```

После этого вы выполняете команду `git reflog`, чтобы посмотреть журнал операций с объектами в Git, и видите такой вывод:

```
5f62b1c HEAD@[0]: reset: moving to HEAD-1
a2f3143 HEAD@{1}: commit: Fix for form functionality
5f62b1c HEAD@{2}: commit: Initial implementation of form functionality
```

Какая команда была выполнена и какую команду теперь надо выполнить, чтобы восстановить ваши изменения?

- [x] Выполнена git reset --hard, которая удалила коммит а2f3143, а для восстановления надо выполнить git cherry-pick a2f3143
- [ ] Выполнена git reset --soft, которая удалила коммит а2f3143 и перенесла изменения в staging area, а для восстановления надо выполнить git commit
- [ ] Выполнена git rebase, из-за которой коммит а2f3143 был потерян, а для восстановления надо выполнить git stash pop
- [ ] Выполнена git reset --mixed, которая удалила коммит а2f3143 и оставила изменения в рабочей директории, а для восстановления надо выполнить git commit
- [ ] Выполнена git revert, отменившая изменения из коммита a2f3143, а для восстановления надо выполнить git revert HEAD

#### Вы работаете в ветке feature/new-customer-model и завершаете в ней разработку. Пробуете отправить изменения в удаленный репозиторий и выполняете команду git push, после чего видите на экране такой вывод:

```
fatal: The current branch feature/new-customer-model has no upstream branch.
```

Что произошло и какую команду надо выполнить, чтобы решить проблему и запушить изменения?

- [ ] Вы работаете не в своей ветке - надо переключиться на ветку main и выполнить `git push origin main`
- [ ] У вас нет доступа к удаленному репозиторию надо проверить настройки авторизации
- [x] Ветка feature/new-customer-model еще не создана на удаленном сервере origin feature/new-customer-model - надо выполнить git push --set-upstream
- [ ] Ветка feature/new-customer-model удалена из удаленного репозитория надо выполнить git branch --upstream origin/feature/new-customer-model
- [ ] Ветка feature/new-customer-model конфликтует с другой веткой надо выполнить git pul перед git push

#### Вы работаете в команде по методологии Git Flow. Один из ваших коллег выполнил слияние ветки feature/new- db-constraints B develop командой git merge --squash feature/new-db-constraints, а затем создал новый коммит с описанием изменений. При этом новый коммит, добавленный в ветку develop, включает в себя все изменения из ветки feature/new- db-constraints как единый блок без сохранения истории коммитов. Оцените, соответствует ли такое действие коллеги принципам работы с ветками по методологии Git Flow?

- [ ] Соответствует, потому что слияние происходит без конфликтов и с сохранением общей структуры веток
- [ ] Не соответствует, потому что в GitFlow feature-ветки надо сливать с веткой main или master
- [ ] Соответствует, потому что при слиянии feature-ветки в ветку разработки надо соблюсти принцип минимального количества отдельных коммитов
- [ ] Не соответствует, потому что методология Git Flow требует мгновенного удаления feature-ветки после merge
- [x] Не соответствует, потому что в Git Flow предполагается использование стандартного слияния с сохранением всех коммитов из feature-ветки, а флаг--squash в команде merge объединяет всё в один коммит

#### Вы обнаружили ошибку в текущей версии проекта и хотите использовать команду git bisect для поиска коммита, который создал эту ошибку. Вы знаете, что ошибка не воспроизводится в коммите с хешем 9939с09, а хеш коммита текущей версии проекта - с1е97f1. Какую команду надо выполнить для начала работы с git bisect?

- [x] git bisect start c1e97f1 99a9c09
- [ ] git bisect reset
- [ ] git bisect good 99a9c09
- [ ] git bisect bad c1e97f1
- [ ] git bisect start 99a9c09 c1e97f1

#### Для чего используется Git Submodules?

- [ ] Для объединения нескольких репозиториев в один, чтобы они работали как единое целое
- [ ] Для работы с несколькими независимыми репозиториями в одном проекте
- [ ] Для удаления веток из другого репозитория
- [ ] Для синхронизации версий файлов между несколькими проектами
- [x] Для отслеживания изменений в другом репозитории как части вашего текущего проекта

#### Для чего используется Git LFS?

- [ ] Для отслеживания изменений в исходных кодах и текстовых файлах
- [ ] Для хранения временных файлов, создаваемых во время сборки проекта
- [ ] Для ускорения процесса слияния веток в проекте с большими файлами
- [ ] Для автоматического обновления версий файлов в репозитории
- [x] Для хранения больших бинарных файлов, таких как изображения, видео или архивы

#### Ваш коллега, работая над коммитами в ветке main, заметил: история коммитов в ней содержит коммит 325b012 с очень большим файлом debug.log и другими изменениями. Этот файл уже удален из репозитория в коммите 8dd9645, но всё еще существует в истории и усложняет работу с репозиторием. Он выполнил какую-то операцию с деревом коммитов и удалил этот файл из всех предыдущих коммитов.

Начальное состояние ветки - вывод git log --oneline:

```
f1fe759 (HEAD -> main) Fixed documentation and comments
8dd9645 Removed debug. log
c60f0ed Finished main feature
325b012 Added model implementation
e21d3cc Initial commit
```

На мобильной платформе присутствует горизонтальный скролл кода
Итоговое состояние ветки (вывод git log --oneline):

```
62db399 (HEAD -> main) Fixed documentation and comments
af98fe5 Removed debug.log
f7048f0 Finished main feature
4d1dde5 Added model implementation
e21d3cc Initial commit
```

На мобильной платформе присутствует горизонтальный скролл кода

Какую операцию из перечисленных выполнил ваш коллега?

- [ ] Выполнил git cherry-pick для удаления файла и пересоздал коммиты вручную
- [x] Выполнил git filter-branch --tree-filter "rm -f debug.log"----all
- [ ] Выполнил git filter-branch-index-filter "git rm--cached debug1.log"----all
- [ ] Выполнил git commit-amend, удалив файл вручную, а затем перезаписал историю командой git push-force
- [ ] Выполнил git rebase -і для редактирования коммита и удаления файла

#### Какой метод используется для обеспечения безопасности отдельных коммитов в Git?

- [ ] Использование специальных ключей ЅЅH для аутентификации на сервере Git
- [ ] Использование Git hooks для автоматической проверки кода перед коммитом
- [ ] Хранение коммитов в защищенном репозитории на удаленном сервере
- [ ] Создание веток с уникальными именами для каждого коммита
- [x] Подпись коммитов с помощью GPG для подтверждения авторства и целостности данных

#### Во время выполнения команды git commit вы замечаете, что процесс коммита прерывается из-за ошибки. Ошибка выглядит так:

```
Running pre-commit hook...
Error: failed
```

Чем вызвана проблема и как ее можно обойти?

- [ ] Проблема вызвана ошибкой в конфигурации хука для временного отключения проверки надо удалить файл .git/hooks/pre-commit
- [ ] Проблема вызвана ошибкой в конфигурации хука post-commit для временного отключения хука надо выполнить команду git hooks disable post-commit
- [ ] Проблема вызвана ошибкой в конфигурации хука pre-commit чтобы ее исправить, надо выполнить команду git config--global core.hooks.pre-commit disable
- [ ] Проблема вызвана ошибкой в конфигурации хука для временного отключения хука надо переместить файл .git/hooks/pre-commit в директорию .git/hooks/disabled
- [x] Проблема вызвана некорректной настройкой имени пользователя чтобы ее исправить, надо сделать коммит в таком виде: git commit--no-verify

#### Вы завершили разработку новой версии проекта и хотите отметить текущий коммит как версию ѵ1.0, чтобы ее можно было легко найти в репозитории и использовать для установки на сервер. Также вашей команде нужно понимать, кто и когда отметил данную версию. Какой командой это можно сделать?

- [x] git tag -a v1.0 -m "Release version 1.0"
- [ ] git branch v1.0
- [ ] git tag v1.0
- [ ] git commit -m "v1.0 release"
- [ ] git push origin v1.0

#### Вы работаете над проектом и находитесь в середине важной задачи. Вам надо переключиться на другую ветку, но при этом сохранить текущие незавершенные изменения, чтобы можно было вернуться к ним позже. Какую команду в Git надо использовать, чтобы сохранить изменения без создания нового коммита?

- [ ] git commit -am "save changes"
- [ ] git checkout.
- [ ] git merge --abort
- [x] git stash
- [ ] git reset --hard

#### Какую команду в Git используют для оптимизации репозитория и удаления неиспользуемых объектов: старых коммиты и объектов, не связанных с текущими ветками?

- [ ] git reset
- [ ] git merge
- [x] git gc
- [ ] git pull
- [ ] git commit--amend

#### Вы работаете над проектом. В ветке feature/mvр у вас есть несколько коммитов, и вы хотите исправить последние три коммита, включая текущий. В одном из них есть ошибка, которую вы хотите исправить, а в другом - неудачное название. Вы хотите изменить порядок коммитов, исправить ошибку и изменить название коммита, чтобы улучшить историю проекта перед push изменений в основную ветку. Какую команду в Git надо использовать, чтобы выполнить всё это в интерактивном режиме?

- [x] git rebase -i HEAD~3
- [ ] git reset -i HEAD~3
- [ ] git pull --rebase -i HEAD~3
- [ ] git merge --no-ff feature/mvp
- [ ] git cherry-pick HEAD~3

#### Разработчик вручную редактирует файлы в git/objects, чтобы восстановить поврежденные данные.

Оцените корректность такого подхода.

- [ ] Это невозможно — файлы в директории .git являются readonly
- [ ] Это некорректно - редактирование возможно, только если используется bare-репозиторий
- [ ] Это допустимо при работе с низкоуровневыми командами Git
- [x] Это некорректно — такие действия могут привести к повреждению репозитория
- [ ] Это корректно, если он точно знает структуру объектов

#### Какой подход использовать, если после переименования файла система отображает его как удаление и создание нового файла, но необходимо сохранить историю изменений?

- [ ] Редактировать .gitignore
- [ ] Выполнить git reset ‹файл>
- [ ] Использовать git rm и git add отдельно
- [ ] Оставить файл в старом каталоге
- [x] Применить git mv для переименования

#### Для CI/CD необходим доступ к файлу secrets. json , однако его нельзя коммитить. Как правильно поступить?

- [x] Добавить файл в gitignore, передавать через переменные окружения
- [ ] Переименовать файл
- [ ] Загружать вручную на сервер
- [ ] Оставить файл в репозитории
- [ ] Зашифровать файл и хранить в репозитории

#### Вы работаете в ветке feature/user-settings, которая была создана из ветки main. B main после этого никто не делал изменений. Вы завершаете работу в feature/user-settings и выполняете:

```
git checkout main
git merge feature/user-settings
```

Git выполняет слияние без создания нового merge-коммита.
Почему merge прошел «тихо» и как это поведение можно изменить?

- [x] Git выполнил fast-forward , так как в main не было новых коммитов. Чтобы избежать этого, можно использовать --no-ff
- [ ] Такое поведение возможно только при наличии git hook - merge произошел потому, что был настроен pre-merge hook
- [ ] Это поведение связано с тем, что ветка не была отправлена в origin, — надо было сначала выполнить git push
- [ ] Git автоматически склеил коммиты, потому что ветка была короткой, — используйте --preserve-history
- [ ] Git проигнорировал merge, потому что в main не было коммита с конфликтующими файлами

#### Ваша коллега уже синхронизировалась с веткой, откуда вы хотите удалить последний коммит. Какой откат безопасней?

- [ ] git cherry-pick
- [ ] git rm --cached
- [ ] git stash pop
- [ ] git reset --hard HEAD~1
- [x] git revert HEAD

#### Если вы хотите изменить ветку, на которую указывает подмодуль, что необходимо сделать?

- [ ] Изменить ветку в подмодуле и выполнить коммит в основном репозитории
- [ ] Удалить подмодуль и добавить его заново с нужной веткой
- [ ] Подмодули не поддерживают смену веток
- [ ] Выполнить `git submodule update --branch` с указанием новой ветки
- [x] Выполнить `git checkout` нужной ветки в подмодуле и зафиксировать изменения в основном репозитории

#### В ветке hotfix необходимо было исправить ошибку в нескольких старых коммитах.

После исправлений история выглядит так:

```
f3eld5c (HEAD →> hotfix) Fix critical bug
a14b9c7 Implemented feature X d5c3a20 Added temporary files
7c9b8f2 Initial commit

Итоговое состояние:
b4a9d2f (HEAD →> hotfix) Fix critical bug and removed temporary files a14b9c7
Implemented feature X
7c9b8f2 Initial commit
```

Какой метод был использован для изменения истории?

- [ ] Выполнен `git commit` --amend и принудительный пуш
- [x] Выполнен `git rebase -i` с редактированием коммитов и удалением временных файлов
- [ ] Выполнен `git revert` коммита с временными файлами
- [ ] Выполнен `git filter-branch --tree-filter` для удаления временных файлов
- [ ] Выполнен `git cherry-pick` нужных коммитов в новую ветку, без включения коммита с временными файлами

#### В вашем проекте используется подмодуль для документации, который находится в каталоге docs/. Вы узнали, что в удаленном репозитории этого подмодуля, например, на ветке release появились важные обновления

Какой командой из корневой папки проекта следует обновить подмодуль docs/ до последней версии из удаленного репозитория и подготовить это изменение к коммиту?

- [ ] git fetch docs/ && git merge docs/FETCH_HEA
- [ ] git pull --recurse-submodules
- [ ] git submodule update --init docs/
- [ ] cd docs/ && git pull && cd .. && git commit -am "Обновление"
- [x] git submodule update --remote docs/

#### В процессе интерактивного перебазирования (git rebase -i HEAD-4 ) разработчик случайно выбрал опцию drop для одного из важных коммитов. Он осознал ошибку сразу после завершения перебазирования. Каким способом можно найти этот «потерянный» коммит и применить его (например, через cherry-pick) к текущей вершине ветки?

- [ ] git log --all --grep="<уникальная*часть*сообщения \_коммита>", найти хеш, git cherry-pick ‹найденный хеш>
- [ ] git reset --hard ORIG HEAD (чтобы отменить весь rebase), затем повторить git rebase -i HEAD~4 более внимательно
- [x] git reflog, найти хеш коммита, который был удален (он будет в reflog с его состоянием до начала rebase), затем git cherry-pick <хеш*потерянного*коммита>
- [ ] git fsck --lost-found, перейти в каталог .git/lost-found/commit , найти файл коммита, git cherry-pick <xeш*из*имени_файла>
- [ ] git rebase --abort (не сработает, т. к. rebase уже завершен), затем искать коммит вручную

#### Вы работаете над новой фичей в ветке dev. Внезапно возникает необходимость срочно переключиться на ветку main для быстрого исправления опечатки в файле README.md.

У вас есть несколько незакоммиченных изменений: в src/feature.js (неиндексированные) и styles/main.css (проиндексированные). Вы хотите временно сохранить все эти изменения, чтобы потом вернуться к ним в ветке dev.
Какую последовательность команд следует использовать для этого?

- [x] git stash push -m "WIP on feature" && git checkout main && [fix] && checkout dev && git stash pop
- [ ] git stash && git checkout main && [fix] && git checkout dev && git stash apply
- [ ] git add. && git stash && git checkout main && [fix] && git checkout dev stash drop
- [ ] git stash save "WIP on feature" && git checkout main && [fix] && git checkout dev && git stash pop
- [ ] git commit -m "Temp commit" && git checkout main && [fix] && git checkout dev && git reset HEAD^

#### Для чего предназначен git-xyk post-receive?

- [ ] Для сбора статистики до пуша
- [ ] Для открытия pull request
- [ ] Для проверки кода перед коммитом
- [ ] Для генерации логов после мержа
- [x] Для деплоя или уведомлений после приема пуша на сервер

#### Во время интерактивного rebase вы случайно оставили конфликт в одном из файлов. Что нужно сделать после его исправления, чтобы продолжить процесс?

- [ ] Запустить git pull, чтобы синхронизировать изменения
- [x] Добавить файл через git add , затем выполнить git rebase --continue
- [ ] Сохранить изменения через git stash , затем продолжить
- [ ] Выполнить git commit -m "Fix", затем git rebase --skip
- [ ] Выполнить git rebase --abort , чтобы начать заново
